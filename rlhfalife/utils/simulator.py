import itertools
from typing import List, Any, Callable, TYPE_CHECKING
from pathlib import Path

if TYPE_CHECKING:
    from .generator import Generator
    from ..data_managers import DatasetManager, PairsManager

class Simulator:
    """
    Abstract Simulator class for the alife model
    
    It is expected to be able to run a simulation with parameters generated by a Generator.
    Parameters are anything that can be used to configure the simulation.

    For example, for a cellular automaton, the parameters could be the initial state of the grid, or the neighborhood function.
    """

    def __init__(self, generator: "Generator"):
        """
        Initialize the simulator with a generator.

        Args:
            generator: Generator to use for generating parameters
        """
        self.generator = generator

    #-------- To implement --------#
    def run(self, params: List[Any]) -> List[Any]:
        """
        Run the simulation with the given parameters.
        The outputs must be viewable by the Rewarder.

        Args:
            params: Parameters to run the simulation with

        Returns:
            The outputs of the simulation
        """
        raise NotImplementedError("Simulator.run must be implemented in inheriting class")

    def save_output(self, output: Any, path: str) -> str:
        """
        Save the output to the path.

        Args:
            output: Output to save
            path: Path to the file to save the output to. The path is the path to the file to save the output to, only the extension is expected to be specified by the user.

        Returns:
            The path to the saved output

        Example usage:
            save_output(output, "out/profile/outputs/output_number1")
            It is expected that the output will be saved in "out/profile/outputs/output_number1<extension chosen by the user>"

        Note: we do not ask for a load_output method, as the the loading of the outputs cannot be automated, since those outputs can be very big data. Therefore we let the user implement the loading in the Rewarder, from the paths given by the TrainingDataset.
        """
        raise NotImplementedError("Simulator.save_output must be implemented in inheriting class")

    def save_video_from_output(self, output: Any, path: str) -> None:
        """
        Convert the output to a video and save it at path.
        It is important that the video is a .mp4 file !


        Args:
            output: Output to save
            path: Path to the file to save the video to

        Example usage:
            save_video_from_output(output, "out/profile/videos/video_number1.mp4")
        """
        raise NotImplementedError("Simulator.save_video_from_output must be implemented in inheriting class")

    def save_param(self, param: Any, path: str) -> str:
        """
        Save the param to the path.
        
        Args:
            param: Parameters of a simulation to save
            path: Path to the file to save the parameter to. The path is the path to the file to save the parameter to, only the extension is expected to be specified by the user.
        
        Example usage:
            save_param(param, "out/profile/params/param_number1")
            It is expected that the param will be saved in "out/profile/params/param_number1<extension chosen by the user>"
        """
        raise NotImplementedError("Simulator.save_param must be implemented in inheriting class")

    def load_output(self, path: str) -> Any:
        """
        Load the output from the path.

        Args:
            path: Path to the file to load the output from. The path is the path to the file to load the output from. No need to specify the extension.

        Returns:
            The loaded output
        """
        raise NotImplementedError("Simulator.load_output must be implemented in inheriting class")
    
    def load_param(self, path: str) -> Any:
        """
        Load the param from the path.

        Args:
            path: Path to the file to load the parameter from. The path is the path to the file to load the parameter from. No need to specify the extension.

        Returns:
            The loaded parameter
        """    
        raise NotImplementedError("Simulator.load_param must be implemented in inheriting class")

    #-------- Built in --------#
    def generate_pairs(self, nb_params: int, dataset_manager: "DatasetManager", pairs_manager: "PairsManager", 
                      batch_size: int = None, verbose: bool = False, progress_callback: Callable[[str], bool] = None) -> bool:
        """
        Generate pairs of simulations to be ranked.
        Add the new simulations to the pairs.csv for all possible pairs, including existing ones.
        
        Args:
            nb_params: Total number of parameters to generate
            dataset_manager: DatasetManager instance for storing simulation data
            pairs_manager: PairsManager instance for storing pairs
            batch_size: Number of parameters to generate in each batch. If None, all parameters are generated in one batch.
            verbose: Whether to print verbose output
            progress_callback: Optional callback function to report progress
                              Should accept a message string and return True to continue, False to cancel
        """
        # Helper function to report progress
        def report_progress(message):
            if verbose: 
                print(message)
            if progress_callback:
                progress_callback(message)
        
        if batch_size is None:
            batch_size = nb_params
        
        num_batches = (nb_params + batch_size - 1) // batch_size # Calculate number of batches, ceiling division
        
        all_generated_hashes = []
        for batch_num in range(num_batches):
            current_batch_size = min(batch_size, nb_params - (batch_num * batch_size))
            if current_batch_size <= 0:
                break

            report_progress(f"Processing Batch {batch_num + 1}/{num_batches} (Size: {current_batch_size})...")

            # Generate parameters
            report_progress(f"  Generating {current_batch_size} parameters...")
            params = self.generator.generate(current_batch_size)

            # check if two params are the same
            if any(str(params[i]) == str(params[j]) for i in range(len(params)) for j in range(i+1, len(params))):
                print("\n" + "="*50)
                print("!!! WARNING !!!: Generator generated at least two identical parameters within a batch.")
                # filter out the identical parameters
                unique_params_in_batch = []
                seen_params_str = set()
                for p in params:
                    p_str = str(p)
                    if p_str not in seen_params_str:
                        unique_params_in_batch.append(p)
                        seen_params_str.add(p_str)
                params = unique_params_in_batch
                print(f"  Unique parameters in this batch: {len(params)}, over {current_batch_size} generated.")
                print("="*50 + "\n")
            
            if not params: # if all params in batch were duplicates or batch size was 0
                report_progress(f"  Skipping Batch {batch_num + 1} due to no unique parameters.")
                continue

            hashs = [str(h) for h in self.generator.hash_params(params)]
            all_generated_hashes.extend(hashs)

            # Run simulations
            report_progress(f"  Running {len(params)} simulations...")
            outputs = self.run(params)

            # Save parameters
            report_progress("  Saving parameters...")
            param_paths = self.save_params(hashs, params, dataset_manager.out_paths['params'])
            
            # Save outputs
            report_progress("  Saving outputs...")
            output_paths = self.save_outputs(hashs, outputs, dataset_manager.out_paths['outputs'])

            # Save videos
            report_progress(f"  Generating and saving {len(outputs)} videos...")
            video_paths = self.save_videos(hashs, outputs, dataset_manager.out_paths['videos'])

            # Add entries to dataset manager
            report_progress(f"  Adding {len(hashs)} entries to dataset manager...")
            dataset_manager.add_entries_from_simulation(hashs, params, outputs, param_paths, output_paths, video_paths)

        if not all_generated_hashes:
            report_progress("No new simulations were generated (possibly all were duplicates or nb_params was 0).")
            return True

        # Get all existing hashes from the dataset
        report_progress("Loading existing hashes from dataset...")
        existing_hashs = dataset_manager.get_all_hashes() # These include the newly added ones as well

        # Generate all possible pairs of new simulations
        report_progress("Generating new pairs from recently generated simulations...")
        new_pairs = list(set(itertools.combinations(all_generated_hashes+existing_hashs, 2)))

        # Add new pairs to the pairs manager
        if new_pairs:
            report_progress(f"Adding {len(new_pairs)} new pairs to pairs manager...")
            pairs_manager.add_pairs(new_pairs)
        else:
            report_progress("No new unique pairs to add.")
        
        report_progress("Pair generation complete.")
        return True

    def save_videos(self, hashs: List[str], outputs: List[Any], vids_path: str) -> List[str]:
        """
        Save videos from the outputs.

        Args:
            hashs: Hashes of the parameters
            outputs: Outputs to save
            vids_path: Path to the videos folder

        Returns:
            List of paths to the saved videos
        """
        res = []
        for i in range(len(outputs)):
            res.append(str(Path(vids_path) / f"{hashs[i]}.mp4"))
            self.save_video_from_output(outputs[i], res[-1])
        return res

    def save_outputs(self, hashs: List[str], outputs: List[Any], outputs_path: str) -> List[str]:
        """
        Save outputs from the outputs.

        Args:
            hashs: Hashes of the parameters
            outputs: Outputs to save
            outputs_path: Path to the outputs folder

        Returns:
            List of paths to the saved outputs
        """
        res = []
        for i in range(len(outputs)):
            path = Path(outputs_path) / f"{hashs[i]}"
            res.append(self.save_output(outputs[i], str(path)))
        return res

    def save_params(self, hashs: List[str], params: List[Any], path: str) -> List[str]:
        """
        Save parameters.

        Args:
            hashs: Hashes of the parameters
            params: Parameters to save
            path: Path to the parameters folder

        Returns:
            List of paths to the saved parameters
        """
        res = []
        for i in range(len(params)):
            param_path = Path(path) / f"{hashs[i]}"
            res.append(self.save_param(params[i], str(param_path)))
        return res 