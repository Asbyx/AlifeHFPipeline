from rlhfalife import Simulator, Generator
from .lenia import Lenia
from typing import TYPE_CHECKING, List, Any
import torch.nn.functional as F

from .utils.leniaparams import LeniaParams
import torch
from showtens import save_video
from pathlib import Path
from tqdm import tqdm

class LeniaSimulator(Simulator):
    """
    Abstract Simulator class for the alife model

    It is expected to be able to run a simulation with parameters generated by a Generator.
    Parameters are anything that can be used to configure the simulation.

    For example, for a cellular automaton, the parameters could be the initial state of the grid, or the neighborhood function.
    """

    def __init__(
        self, generator: Generator, lenia_automaton: Lenia, run_length: int, frame_portion: int = 5, num_output_frames: int = 12, device='cpu'
    ):
        """
        Initializes the simulator

        Args:
            generator: Generator object
            lenia_automaton: Initialized MCLenia object
            run_length: Number of frames to run the simulation for
            frame_portion: Proportion of frames to keep in output video
            num_output_frames : Number of frames to keep in output tensor. Spaced Linearly
            device: Device to run the simulation on. Defaults to "cpu". If "cuda" is available, it will be used.
        """
        super().__init__(generator)
        self.mlenia = lenia_automaton
        self.run_length = run_length
        self.frame_portion = frame_portion
        self.num_output_frames = num_output_frames
        self.mlenia.to(device)  # move the lenia automaton to the device
        self.max_batch = 20 # TODO : make this a parameter of the simulation
    
    # -------- To implement --------#
    def run(self, params: List[LeniaParams]) -> List[Any]:
        """
        Run the simulation with the given parameters.
        For now, params are LeniaParams

        Args:
            params: Parameters to run the simulation with

        Returns:
            The outputs of the simulation
        """
        all_batch_params= []
        print(f'Generating {len(params)} params in {len(params)//self.max_batch}+{int(len(params)%self.max_batch==0)} batches')

        for k in range(len(params)//self.max_batch):
            slice_params = params[k*self.max_batch:(k+1)*self.max_batch]
            batched_param = slice_params[0]
            for param in slice_params[1:]:
                batched_param = batched_param.cat(param)
            all_batch_params.append(batched_param)

        if len(params) % self.max_batch != 0:
            slice_params = params[-(len(params) % self.max_batch):]
            batched_param = slice_params[0]
            for param in slice_params[1:]:
                batched_param = batched_param.cat(param)
            all_batch_params.append(batched_param)
        
        all_outputs = []
        for batch_params in tqdm(all_batch_params):
            self.mlenia.update_params(batch_params)  # update the parameters of the simulation
            self.mlenia.set_init_fractal()
            B = self.mlenia.batch
            H, W = self.mlenia.h, self.mlenia.w
            C = self.mlenia.C

            outputs = torch.zeros(B, self.run_length // self.frame_portion, C, H, W)
            for i in range(self.run_length):
                self.mlenia.step()
                if i % 5 == 0:
                    self.mlenia.draw()  # update worldmap
                    outputs[:, i // 5] = self.mlenia._worldmap
            all_outputs.extend(outputs.unbind(dim=0))  # (T,C,H,W) list
        
        return all_outputs  # (T,C,H,W) list of tensors
 
    def save_output(self, output: Any, path: str) -> str:
        """
        Save a raw output from the run to the path.

        Args:
            output: Output to save
            path: Path to the file to save the output to. The path is the path to the file to save the output to, only the extension is expected to be specified by the user.

        Returns:
            The path to the saved output

        Example usage:
            save_output(output, "out/profile/outputs/output_number1")
            It is expected that the output will be saved in "out/profile/outputs/output_number1<extension chosen by the user>"

        Note: we do not ask for a load_output method, as the the loading of the outputs cannot be automated, since those outputs can be very big data. Therefore we let the user implement the loading in the Rewarder, from the paths given by the TrainingDataset.
        """
        torch.save(self._process_output(output), path+'.pt')

        return path + '.pt'

    def _process_output(self, tensvid):
        """
            Given a video tensor, returns the processed tensor.

            Args:
            tensvid : (T,3,H,W) representing the videos

            Returns:
            (T',3,H',W') tensor, processed tensvid in model's format
        """

        T,C,H,W = tensvid.shape
        assert self.num_output_frames <= T, f'tensvid {T} frames, need at least {self.num_output_frames} frames'

        # Take self.num_output_frames equally spaced frames
        tensvid = tensvid[torch.linspace(0,T-1,self.num_output_frames).long()] # (T',3,H,W)

        return tensvid

    def save_video_from_output(self, output: Any, path: str) -> None:
        """
        Convert the output to a video and save it at path.
        It is important that the video is a .mp4 file !

        Args:
            output: Output to save
            path: Path to the file to save the video to

        Example usage:
            save_video_from_output(output, "out/profile/videos/video_number1.mp4")
        """
        save_video(output, folder=Path(path).parent, name=Path(path).stem, fps=100//self.frame_portion)

    def save_param(self, param: LeniaParams, path: str) -> str:
        """
        Save the param to the path.

        Args:
            param: Parameters of a simulation to save
            path: Path to the file to save the parameter to. The path is the path to the file to save the parameter to, only the extension is expected to be specified by the user.

        Example usage:
            save_param(param, "out/profile/params/param_number1")
            It is expected that the param will be saved in "out/profile/params/param_number1<extension chosen by the user>"
        """
        param.save(Path(path).parent, Path(path).stem+'.pt')
        return path + '.pt'

    def load_param(self, path: str) -> Any:
        """
        Load the param from the path.

        Args:
            path: Path to the file to load the parameter from. The path is the path to the file to load the parameter from. No need to specify the extension.

        Returns:
            The loaded parameter
        """
        return LeniaParams(from_file=Path(path).with_suffix('.pt'))
